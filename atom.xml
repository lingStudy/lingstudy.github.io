<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>编程之外の个人客栈</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://vogos.cn/"/>
  <updated>2020-08-26T11:16:19.520Z</updated>
  <id>http://vogos.cn/</id>
  
  <author>
    <name>编程之外</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>在竞争日益激烈的互联网行业，我必须要清楚什么？</title>
    <link href="http://vogos.cn/2020/08/26/%E5%9C%A8%E7%AB%9E%E4%BA%89%E6%97%A5%E7%9B%8A%E6%BF%80%E7%83%88%E7%9A%84%E4%BA%92%E8%81%94%E7%BD%91%E8%A1%8C%E4%B8%9A%EF%BC%8C%E6%88%91%E5%BF%85%E9%A1%BB%E8%A6%81%E6%B8%85%E6%A5%9A%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
    <id>http://vogos.cn/2020/08/26/%E5%9C%A8%E7%AB%9E%E4%BA%89%E6%97%A5%E7%9B%8A%E6%BF%80%E7%83%88%E7%9A%84%E4%BA%92%E8%81%94%E7%BD%91%E8%A1%8C%E4%B8%9A%EF%BC%8C%E6%88%91%E5%BF%85%E9%A1%BB%E8%A6%81%E6%B8%85%E6%A5%9A%E4%BB%80%E4%B9%88%EF%BC%9F/</id>
    <published>2020-08-26T10:25:37.000Z</published>
    <updated>2020-08-26T11:16:19.520Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;前两天在B站，看到一位UP主发布的一个视频“<strong>你们慢慢写吧，我再也不想写代码了，蓉漂程序员回农村，闲适的农村生活从一杯早茶开始</strong>”，由于BGM是《稻香》勾起了我想继续了解的欲望，点开他的简介写着“<strong>java后端码农转菜农，java从入门到精..放弃。</strong>”，再看了他发布的其他视频，我了解到他之前也是做Java开发的，现在已经回到老家，做自媒体了。</p><p>&emsp;&emsp;互联网飞速发展的21世纪，在这个“<strong>三百六十行，行行转计算机</strong>”的背景下，其实上面类似的情况还有非常多！其他行业我不太了解，IT互联网特别是编程类的，即使不是科班出身，报一个培训机构学几个月出来，能力比一些二流大学的科班学生还要强很多，这也是很多人转行就转计算机的重要原因之一！</p><p>&emsp;&emsp;越来越多的人进入这个行业，就出现了很多问题，暂且撇开剧增的竞争压力不谈，这种现象也让一些资本家看到了其背后巨大的“<strong>暴利</strong>”！各种培训机构开始疯狂涌现，为了招收到更多的学员，在宣传上打着“包就业”的旗号，还有各种贷款免息等……一个人几万的培训费，一个班就招了四五十人甚至更多，到最后每个人都做着同一套万年“<strong>电商系统</strong>”，为了让你顺利找到工作就教你在简历花“<strong>心思</strong>”，这行业被一些培训机构整得乌烟瘴气！当然，说的只是部分培训机构，我了解的还是有非常良心的培训机构的。坑很多，就看自己怎么甄别了！</p><p>&emsp;&emsp;现在这行业的大环境就是这样，经过自己的一些经历见闻，以及和一些大佬的接触，给自己概括出以下三点：</p><p>1、准备要进入这个行业的你，真的考虑清楚，真的了解这个行业吗？</p><p>2、已经身处这个行业的你，如何在这激烈的竞争中，在一次次的裁员中不被新人取代？那么多人竞争一个岗位，我不是985、211凭什么留下来的是我？万人过独木桥，比我优秀的人那么多，凭什么走到对岸的不是别人？</p><p>3、会用几个主流框架就很厉害了？它们的底层实现原理知道吗，点进源码看过吗？23种设计模式认识几种？几大Java集合框架知道它们底层的数据结构吗？JVM底层又了解多少？数据库索引的数据结构，算法与优化……这些都是面试重点，真正面试时我能答上来几个！</p><hr><h2 id="我必须要做什么？"><a href="#我必须要做什么？" class="headerlink" title="我必须要做什么？"></a>我必须要做什么？</h2><p>&emsp;&emsp;不断的学习充实自己，永不停止脚步，提升自己的竞争力，公众号第一篇文章就是关于“坚持学习，积薄为厚！”的毒鸡汤！上面第三点，是提升自己的竞争力，让自己不轻易被取代的重点！</p><p>&emsp;&emsp;要学会自己造轮子，因为大部分人都停留在会使用别人的技术，而不是“创造”！当然前提是会用了，知道底层实现了，才有可能去创造。前几天在学习 Elasticsearch 时做了一张简图，很多情况下都停留在应用层，只是技术永远都在更新迭代，学不完每一个技术！</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200826184019560.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM2NTUzMA==,size_16,color_FFFFFF,t_70#pic_center" class="lazyload"></p><hr><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>&emsp;&emsp;要最后，告诫自己：“身体健康很重要，不然 996 换来的却是 ICU，不值！公司不是自己的家，你没有价值了随时被炒！多给自己准备几条路，即使没有那份工作了也影响不大！”</p>]]></content>
    
    <summary type="html">
    
      “身体健康很重要，不然 996 换来的却是 ICU，不值！公司不是自己的家，你没有价值了随时被炒！多给自己准备几条路，即使没有那份工作了也影响不大！”
    
    </summary>
    
    
      <category term="随笔" scheme="http://vogos.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="996" scheme="http://vogos.cn/tags/996/"/>
    
      <category term="ICU" scheme="http://vogos.cn/tags/ICU/"/>
    
      <category term="竞争" scheme="http://vogos.cn/tags/%E7%AB%9E%E4%BA%89/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫+数据清洗+数据可视化基础案例</title>
    <link href="http://vogos.cn/2020/08/01/Python%E7%88%AC%E8%99%AB+%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97+%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%9F%BA%E7%A1%80%E6%A1%88%E4%BE%8B/"/>
    <id>http://vogos.cn/2020/08/01/Python%E7%88%AC%E8%99%AB+%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97+%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%9F%BA%E7%A1%80%E6%A1%88%E4%BE%8B/</id>
    <published>2020-08-01T04:31:43.000Z</published>
    <updated>2020-08-02T06:04:18.500Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><table><td bgcolor="#AEEEEE"></td></table><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;最近迷上了Python爬虫，我们的hadoop课程也正好涉及到了这个内容，所以就想结合课程内容(爬取京东手机评论<a href="https://item.jd.com/100003060627.html#crumb-wrap" target="_blank" rel="noopener">https://item.jd.com/100003060627.html#crumb-wrap</a>)写一篇关于python爬虫到数据可视化的完整流程。</p><table><td bgcolor="green"></td></table><p>&emsp;&emsp;打开目标网站<a href="https://item.jd.com/100003060627.html#crumb-wrap" target="_blank" rel="noopener">https://item.jd.com/100003060627.html#crumb-wrap</a>我们要爬取该手机的评论信息，就要先找到“我们点击查看评论时，浏览器向服务器请求来的文件”在该文件中有我们需要的url地址和求头(请求头包括referer：重定向 和 user-agent：用户代理)，浏览器都会有一些反爬虫的措施，所以需要使用该请求头去模拟浏览器向服务器请求数据。至于怎么找到我们需要的文件，博主只能说：这需要一些前端的知识和自己的经验，<del>爬虫做多了</del>  额…不对，这样不太好，爬虫是有些偏灰暗的，我是说熟能生巧啊。可以先看一下文件的Preview，如下即为我们需要的信息文件，然后点击Headers先复制我们需要的信息到编译器中，为我们待会写代码时准备：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191204190140267.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM2NTUzMA==,size_16,color_FFFFFF,t_70" class="lazyload"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191204190438751.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM2NTUzMA==,size_16,color_FFFFFF,t_70" class="lazyload"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191204190600326.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM2NTUzMA==,size_16,color_FFFFFF,t_70" class="lazyload"></p><table><td bgcolor="#AEEEEE"></td></table><h1 id="获取并筛选数据"><a href="#获取并筛选数据" class="headerlink" title="获取并筛选数据"></a>获取并筛选数据</h1><p>&emsp;&emsp;拿到我们需要的url地址和请求头后，先分析一下url地址，主要是它的后半部分，它是由字符串拼接而成的，比如这里的url地址：<code>https://sclub.jd.com/comment/productPageComments.action?callback=fetchJSON_comment98vv21252&amp;productId=100003060627&amp;score=0&amp;sortType=5&amp;page=0&amp;pageSize=10&amp;isShadowSku=0&amp;fold=1</code><br>在这里**page=**后面跟的就是第几页评论的信息（数据），不信你点击第二页评论时page=后面就是1&amp;pageSize=10&amp;isShadowSku=0&amp;fold=1，由0变为了1（感觉在侮辱自己的智商(艹皿艹)），由此我们可以将url地址切割为两部分，将变化的数据用变量表示，然后再将两部分拼接得到最终的url地址，我们就可以通过控制变量来获取对应的数据量了，如下为切割和拼接的过程和结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#切割后第一部分</span></span><br><span class="line">url_header=<span class="string">"https://sclub.jd.com/comment/productPageComments.action?callback=fetchJSON_comment98vv19450&amp;productId=100003060627&amp;score=0&amp;sortType=5&amp;page="</span></span><br><span class="line"><span class="comment">#切割后第二部分</span></span><br><span class="line">url_tail=<span class="string">"&amp;pageSize=10&amp;isShadowSku=0&amp;rid=0&amp;fold=1"</span></span><br><span class="line"><span class="comment">#拼接得到最终url地址(后面用循环改变page的值，此处加1，即从第二页开始获取数据，也可以不加1)</span></span><br><span class="line">url_mate20=url_header + str(page+<span class="number">1</span>) + url_tail</span><br></pre></td></tr></table></figure><table><td bgcolor="#AEEEEE"></td></table><p><strong>现在正式开始搬砖了，先导入我们需要用到的两个库，也可以叫包、模块</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br></pre></td></tr></table></figure><table><td bgcolor="#AEEEEE"></td></table>&emsp;&emsp;利用请求头和拼接得到的最终url，循环请求每一条评论数据，并将请求到的数据转化格式为json格式保存为本地的txt文件，如下我保存到自己电脑D:\python_data目录下<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> page <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">    url_tail=<span class="string">"&amp;pageSize=10&amp;isShadowSku=0&amp;rid=0&amp;fold=1"</span></span><br><span class="line">    <span class="comment"># 拼接得到最终url,并请求数据(得到键值对格式(字典)的数据)</span></span><br><span class="line">    url_mate20=url_header + str(page+<span class="number">1</span>) + url_tail</span><br><span class="line">    res=requests.get(url_mate20,headers=headers)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 用json.loads将数据转化格式为json格式</span></span><br><span class="line">    data=json.loads(res.text[<span class="number">27</span>:<span class="number">-2</span>])</span><br><span class="line">    comment=(data[<span class="string">'comments'</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将数据遍历保存到本地的.txt文件中,</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> comment:</span><br><span class="line">        <span class="comment"># 注意带参数"a"，如果是w就会覆盖原有内容，这样子你只能得一条评论</span></span><br><span class="line">        honor20i_text=open(<span class="string">'D:\\python_data\\honor20i_text.txt'</span>,<span class="string">'a'</span>)</span><br><span class="line">        honor20i_text.write(<span class="string">'%s\n'</span>%i[<span class="string">'content'</span>])</span><br><span class="line">        honor20i_text.close()</span><br></pre></td></tr></table></figure><table><td bgcolor="#AEEEEE"></td></table><p>&emsp;&emsp;此时运行程序会在指定目录下生成一个txt文件，打开可看见即为我们获取到的评论数据，看起来有点乱，可以在请求的时候自己做一下格式美化，后面我要将获取到的txt数据可视化(词云)，所以这里就不用做美化了啊<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191204224155527.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM2NTUzMA==,size_16,color_FFFFFF,t_70" class="lazyload"></p><table><td bgcolor="#AEEEEE"></td></table><h1 id="数据可视化（词云形式，激动ヾ-✿ﾟ▽ﾟ-ノ）"><a href="#数据可视化（词云形式，激动ヾ-✿ﾟ▽ﾟ-ノ）" class="headerlink" title="数据可视化（词云形式，激动ヾ(✿ﾟ▽ﾟ)ノ）"></a>数据可视化（词云形式，激动ヾ(✿ﾟ▽ﾟ)ノ）</h1><p><strong><em>同样先导包</em></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"><span class="keyword">from</span> wordcloud <span class="keyword">import</span> WordCloud</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt <span class="comment">#可视化包</span></span><br></pre></td></tr></table></figure><table><td bgcolor="#AEEEEE"></td></table>&emsp;&emsp;下面读取我们获取到的txt文件内容，再使用jieba来处理剪切我们爬取的文本内容，继续处理对剪过的文本以空格拼接起来，然后就是利用matplotlib包设置一下显示的字体样式和保存显示结果了<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line">    <span class="keyword">from</span> wordcloud <span class="keyword">import</span> WordCloud</span><br><span class="line">    <span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt <span class="comment">#可视化包</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#读取爬虫保存下载的数据</span></span><br><span class="line">    file_text = open(<span class="string">'D:\\python_data\\honor20i_text.txt'</span>,<span class="string">'r'</span>).read()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#再使用jieba来处理剪切我们爬取文本内容</span></span><br><span class="line">    cut_text = jieba.cut(file_text)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#继续处理对剪过的文本以空格拼接起来，注意一下这里“”有空格的</span></span><br><span class="line">    result = <span class="string">" "</span>.join(cut_text)</span><br><span class="line"></span><br><span class="line">    wc_cloud = WordCloud(</span><br><span class="line">        font_path=<span class="string">'D:\python_data\\pzh.ttf'</span>,     <span class="comment">#字体的路径</span></span><br><span class="line">        background_color=<span class="string">'black'</span>,   <span class="comment">#背景颜色</span></span><br><span class="line">        width=<span class="number">1200</span>,</span><br><span class="line">        height=<span class="number">600</span>,</span><br><span class="line">        max_font_size=<span class="number">150</span>,            <span class="comment">#字体的大小</span></span><br><span class="line">        min_font_size=<span class="number">30</span>,  <span class="comment">#字体的大小</span></span><br><span class="line">        max_words=<span class="number">10000</span></span><br><span class="line">    )</span><br><span class="line">    wc_cloud.generate(result)</span><br><span class="line">    wc_cloud.to_file(<span class="string">'D:\\python_data\\LingDucloud.png'</span>)    <span class="comment">#图片保存</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#图片展示</span></span><br><span class="line">    plt.figure(<span class="string">'凌度img'</span>)   <span class="comment">#图片显示的名字</span></span><br><span class="line">    plt.title(<span class="string">'JD_mate20'</span>)</span><br><span class="line">    plt.imshow(wc_cloud)</span><br><span class="line">    plt.axis(<span class="string">'off'</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><hr><p>&emsp;&emsp;注意这里用到了.ttf字体包，没有字体包生成的图片是火星文哦😂😂需要字体包的，可以到微信公众号 <strong>编程之外</strong> 输入关键词“<strong>字体包</strong>”免费获取，欢迎小伙伴入坑哦！😁😁😁</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">font_path=<span class="string">'D:\python_data\\pzh.ttf'</span></span><br></pre></td></tr></table></figure><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191204201840208.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM2NTUzMA==,size_16,color_FFFFFF,t_70" class="lazyload"></p><table><td bgcolor="#AEEEEE"></td></table><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200324095154148.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM2NTUzMA==,size_16,color_FFFFFF,t_70#pic_center" class="lazyload"></p><table><tr><td bgcolor="green"></td></tr></table><p>&emsp;&emsp;如下为运行后的可视化词云效果，字体越大越明显的词汇说明在评论内容中出现的次数就越多，此时在指定的路径目录下也会生成相应的图片<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191204221745593.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM2NTUzMA==,size_16,color_FFFFFF,t_70" class="lazyload"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191204221935911.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM2NTUzMA==,size_16,color_FFFFFF,t_70" class="lazyload"></p><table><td bgcolor="#AEEEEE"></td></table>&emsp;&emsp;下面为全部源码，将数据获取和数据可视化分别写成两个方法，在main中分别调用就不用新建两个python文件啦。哪里还不太懂，或者有什么问题(包括和我获取.ttf字体包)欢迎在留言区留下你的脚印哦。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment">#数据爬取方法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gain_data</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#请求头(包括referer：重定向(反爬虫) user-agent：用户代理)</span></span><br><span class="line">    headers=&#123;</span><br><span class="line">        <span class="string">'referer'</span>:<span class="string">'Referer: https://item.jd.com/100003060627.html'</span>,</span><br><span class="line">        <span class="string">'user-agent'</span>:<span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 '</span></span><br><span class="line">                     <span class="string">'(KHTML, like Gecko) Chrome/75.0.3770.80 Safari/537.36'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">#url地址</span></span><br><span class="line">    url_header=<span class="string">"https://sclub.jd.com/comment/productPageComments.action?callback="</span> \</span><br><span class="line">               <span class="string">"fetchJSON_comment98vv19450&amp;productId=100003060627&amp;score=0&amp;sortType=5&amp;page="</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> page <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">        url_tail=<span class="string">"&amp;pageSize=10&amp;isShadowSku=0&amp;rid=0&amp;fold=1"</span></span><br><span class="line">        <span class="comment"># 拼接得到最终url,并请求数据(得到键值对格式(字典)的数据)</span></span><br><span class="line">        url_mate20=url_header + str(page+<span class="number">1</span>) + url_tail</span><br><span class="line">        res=requests.get(url_mate20,headers=headers)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 用json.loads将数据转化格式为json格式</span></span><br><span class="line">        data=json.loads(res.text[<span class="number">27</span>:<span class="number">-2</span>])</span><br><span class="line">        comment=(data[<span class="string">'comments'</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将数据遍历保存到本地的.txt文件中,</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> comment:</span><br><span class="line">            <span class="comment"># 注意带参数"a"，如果是w就会覆盖原有内容，这样子你只能得一条评论</span></span><br><span class="line">            honor20i_text=open(<span class="string">'D:\\python_data\\honor20i_text.txt'</span>,<span class="string">'a'</span>)</span><br><span class="line">            honor20i_text.write(<span class="string">'%s\n'</span>%i[<span class="string">'content'</span>])</span><br><span class="line">            honor20i_text.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#词云可视化方法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mate20_view</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">import</span> jieba</span><br><span class="line">    <span class="keyword">from</span> wordcloud <span class="keyword">import</span> WordCloud</span><br><span class="line">    <span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt <span class="comment">#可视化包</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#读取爬虫保存下载的数据</span></span><br><span class="line">    file_text = open(<span class="string">'D:\\python_data\\honor20i_text.txt'</span>,<span class="string">'r'</span>).read()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#再使用jieba来处理剪切我们爬取文本内容</span></span><br><span class="line">    cut_text = jieba.cut(file_text)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#继续处理对剪过的文本以空格拼接起来，注意一下这里“”有空格的</span></span><br><span class="line">    result = <span class="string">" "</span>.join(cut_text)</span><br><span class="line"></span><br><span class="line">    wc_cloud = WordCloud(</span><br><span class="line">        font_path=<span class="string">'D:\python_data\\pzh.ttf'</span>,     <span class="comment">#字体包的路径</span></span><br><span class="line">        background_color=<span class="string">'black'</span>,   <span class="comment">#背景颜色</span></span><br><span class="line">        width=<span class="number">1200</span>,</span><br><span class="line">        height=<span class="number">600</span>,</span><br><span class="line">        max_font_size=<span class="number">150</span>,            <span class="comment">#字体的大小</span></span><br><span class="line">        min_font_size=<span class="number">30</span>,  <span class="comment">#字体的大小</span></span><br><span class="line">        max_words=<span class="number">10000</span></span><br><span class="line">    )</span><br><span class="line">    wc_cloud.generate(result)</span><br><span class="line">    wc_cloud.to_file(<span class="string">'D:\\python_data\\LingDucloud.png'</span>)    <span class="comment">#图片保存</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#图片展示</span></span><br><span class="line">    plt.figure(<span class="string">'凌度img'</span>)   <span class="comment">#图片显示的名字</span></span><br><span class="line">    plt.title(<span class="string">'JD_mate20'</span>)</span><br><span class="line">    plt.imshow(wc_cloud)</span><br><span class="line">    plt.axis(<span class="string">'off'</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    mate20_view()</span><br></pre></td></tr></table></figure><p>文章到这里就结束啦，感谢参考：<br><a href="https://www.jb51.net/article/154261.htm" target="_blank" rel="noopener">https://www.jb51.net/article/154261.htm</a><br><a href="https://blog.csdn.net/weixin_42946604/article/details/88079475" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42946604/article/details/88079475</a></p><table><td bgcolor="#AEEEEE"></td></table><h1 id="编程之外"><a href="#编程之外" class="headerlink" title="编程之外"></a>编程之外</h1><p>&emsp;&emsp;这是一篇很基础的关于python爬虫的博客文章，大佬看见了一定要在评论区留下宝贵的建议脚印呀！大二的时候就学习过Python这方面的知识了，那时候没什么兴趣，就没有好好学┭┮﹏┭┮，现在也是还在自学中，也看了很多大佬的文章，受益匪浅。最后告诉一下小同学，如果是计算机类、编程类专业并且要走专业路线的话，一定要好好学习数学，今后的人工智能、大数据、数据建模你将会感受到数学的重要性，说到这里真想给自己两jiao(つД`)过去两年怎么不好好学<strong>高数、线性代数、概率论、离散数学和算法</strong>，精神上再给自己一jiao！<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200326162046394.gif#pic_center" class="lazyload"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200326162138290.png" class="lazyload"></p><table><td bgcolor="green"><font size="3px" color="green">编程之外</font></td></table>]]></content>
    
    <summary type="html">
    
      最近迷上了Python爬虫，我们的hadoop课程也正好涉及到了这个内容，所以就想结合课程内容(获取京东手机评论)写一篇关于python爬虫到数据可视化的完整流程。
    
    </summary>
    
    
      <category term="Python" scheme="http://vogos.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://vogos.cn/tags/Python/"/>
    
      <category term="数据清洗" scheme="http://vogos.cn/tags/%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97/"/>
    
      <category term="可视化" scheme="http://vogos.cn/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>该文章页面有毒！！</title>
    <link href="http://vogos.cn/2020/08/01/%E8%AF%A5%E6%96%87%E7%AB%A0%E9%A1%B5%E9%9D%A2%E6%9C%89%E6%AF%92%EF%BC%81%EF%BC%81/"/>
    <id>http://vogos.cn/2020/08/01/%E8%AF%A5%E6%96%87%E7%AB%A0%E9%A1%B5%E9%9D%A2%E6%9C%89%E6%AF%92%EF%BC%81%EF%BC%81/</id>
    <published>2020-08-01T01:07:30.000Z</published>
    <updated>2020-08-04T07:00:26.367Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script>    <!-- 左边live2d --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css">    <script src="https://cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/autoload.js"></script>    <!-- 动态文字================= --><div style="font-family:'STXingkai';font-size: 20px;color: red;">    <span id="subtitle"></span>    <script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11"></script>    <script>        var typed = new Typed("#subtitle", {            strings: ['时间只不过是考验，种在心中信念丝毫未减！',            '一个终身学习者，誓将学习无限循环'],            startDelay: 300,            typeSpeed: 100,            loop: true,            backSpeed: 50,            showCursor: true        });    </script></div><script type="text/javascript" src="//rf.revolvermaps.com/0/0/1.js?i=59imdwvg80a&amp;s=220&amp;m=1&amp;v=true&amp;r=false&amp;b=000000&amp;n=false&amp;c=ff0000" async="async"></script><!-- 动态文字================= --><!--动态线条背景-->    <script type="text/javascript"            color="0,255,0" opacity='1' zIndex="-1" count="500" src="https://cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js">    </script>    <!--============Live-2D看板娘模型======================-->    <script src="https://eqcn.ajz.miesnfu.com/wp-content/plugins/wp-3d-pony/live2dw/lib/L2Dwidget.min.js"></script>    <script type="text/javascript">        //Live-2D看板娘模型        L2Dwidget.init({            model: {                //jsonpath 控制显示那个小萝莉模型，下面这个为可选模型                // hijiki  //izumi //shizuku //koharu  //miku  //epsilon2_1  //chitose  //hibiki  //z16                jsonPath: "https://unpkg.com/live2d-widget-model-miku@1.0.5/assets/miku.model.json", //这里改模型，前面后面都要改                scale: 1,            },            display: {                position: "right", //设置板娘的上下左右位置                width: 200,  //板娘的宽度                height: 300, //板娘的高度                hOffset: -5,  //水平偏移                vOffset: -50  //垂直偏移            },            mobile: {                show: false,  //在移动端不显示                scale: 0.4    //移动设备上的缩放            },            react: {                opacityDefault: 0.8, //设置透明度                opacityOnHover: 0.2            },        });    </script>    <!-- 樱花 -->        <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/wallleap/cdn@latest/js/sakura.js"></script>    <!-- <script src="https://cdn.bootcss.com/jquery/3.5.0/jquery.min.js"></script> -->]]></content>
    
    <summary type="html">
    
      各种花里胡哨的页面特效，别轻易点进来！！！
    
    </summary>
    
    
      <category term="随笔" scheme="http://vogos.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="JS" scheme="http://vogos.cn/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>﻿Vue：Axios异步通信</title>
    <link href="http://vogos.cn/2020/07/30/Vue%EF%BC%9AAxios%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1/"/>
    <id>http://vogos.cn/2020/07/30/Vue%EF%BC%9AAxios%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1/</id>
    <published>2020-07-30T08:46:07.000Z</published>
    <updated>2020-08-01T14:58:50.170Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200407133103120.gif#pic_center" class="lazyload"></p><table><td bgcolor="#AEEEEE"></td></table><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>什么是Axios?</strong><br>&emsp;&emsp;Axios 是一个开源的可以用在浏览器和<code>NodeJS</code>的异步通信框架，它的主要作用就是实现 AJAX异步通信，其功能特点如下：</p><ul><li>从浏览器中创建 <code>XMLHttpRequests</code></li><li>从<code>node.js</code>创建http请求</li><li>支持<code>Promise API [JS中链式编程]</code></li><li>拦截请求和响应</li><li>转换请求数据和响应数据</li><li>取消请求</li><li>自动转换<code>JSON</code>数据</li><li>客户端支持防御XSRF（跨站请求伪造）</li></ul><p>GitHub：<a href="https://github.com/axios/axios" target="_blank" rel="noopener">https://github.com/axios/axios</a></p><p>中文文档：<a href="http://www.axios-js.com/" target="_blank" rel="noopener">http://www.axios-js.com</a></p><hr><p><strong>为什么要使用 Axios ?</strong></p><p>&emsp;&emsp;由于<code>Vue.js</code>是一个视图层框架，并且作者（尤雨溪）严格遵守SOC（关注度分离原则），所以<code>Vue.js</code>并不包含 AJAX 的通信功能，为了解决通信问题，作者单独开发了一个名为<code>vue-resource</code>的插件，不过在进入2.0版本以后停止了对该插件的维护并推荐了 <code>Axios</code> 框架。少用jQuery，因为JQuery操作Dom太频繁！</p><table><td bgcolor="#AEEEEE"></td></table><h1 id="第一个-Axios-应用程序"><a href="#第一个-Axios-应用程序" class="headerlink" title="第一个 Axios 应用程序"></a>第一个 Axios 应用程序</h1><p>&emsp;&emsp;我们开发的接口大部分都是采用 JSON 格式。可以先在项目里模拟一段 JSON 数据，数据内容如下：创建一个data.json 的文件并填入下面的内容，放在项目的根目录下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"编程之外"</span>,</span><br><span class="line">    <span class="string">"url"</span>: <span class="string">"http://vogos.cn"</span>,</span><br><span class="line">    <span class="string">"page"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">"isNonProfit"</span>: <span class="keyword">true</span>,</span><br><span class="line">    <span class="string">"address"</span>: &#123;</span><br><span class="line">        <span class="string">"street"</span>: <span class="string">"lingyun"</span>,</span><br><span class="line">        <span class="string">"city"</span>: <span class="string">"西安"</span>,</span><br><span class="line">        <span class="string">"country"</span>: <span class="string">"中国"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"links"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"name"</span>: <span class="string">"lingStudy"</span>,</span><br><span class="line">            <span class="string">"url"</span>: <span class="string">"http://vogos.cn"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"name"</span>: <span class="string">"我是半斤"</span>,</span><br><span class="line">            <span class="string">"url"</span>: <span class="string">"http://vogos.cn"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"name"</span>: <span class="string">"八两在哪？"</span>,</span><br><span class="line">            <span class="string">"url"</span>: <span class="string">"http://vogos.cn"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试实例：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span> <span class="attr">xmlns:v-bind</span>=<span class="string">"http://www.w3.org/1999/xhtml"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--v-cloak:解决数据加载时闪烁问题--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-attr">[v-cloak]</span>&#123;</span></span><br><span class="line">            display: none;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- view层 模板 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"vue"</span> <span class="attr">v-cloak</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>名称：&#123;&#123;info.name&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>地址：&#123;&#123;info.address.street&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>链接：<span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">"info.url"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span>点击试试<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--导入js文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/axios/dist/axios.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el:<span class="string">"#vue"</span>,</span></span><br><span class="line">        data()&#123;</span><br><span class="line"><span class="actionscript">            <span class="keyword">return</span>&#123;</span></span><br><span class="line"><span class="actionscript">                <span class="comment">// 请求的返回参数格式，必须和json字符串一样</span></span></span><br><span class="line">                info: &#123;</span><br><span class="line"><span class="actionscript">                    name: <span class="literal">null</span>,</span></span><br><span class="line"><span class="actionscript">                    url: <span class="literal">null</span>,</span></span><br><span class="line">                    address: &#123;</span><br><span class="line"><span class="actionscript">                        street: <span class="literal">null</span>,</span></span><br><span class="line"><span class="actionscript">                        city: <span class="literal">null</span>,</span></span><br><span class="line"><span class="actionscript">                        country: <span class="literal">null</span></span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"><span class="actionscript">       mounted()&#123;<span class="comment">//钩子函数  链式编程</span></span></span><br><span class="line"><span class="javascript">            axios.get(<span class="string">'../data.json'</span>).then(<span class="function"><span class="params">response</span>=&gt;</span>(<span class="keyword">this</span>.info=response.data));</span></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><p><strong>说明：</strong></p><p>1.在这里使用了<code>v-bind</code>将 <code>a:href </code>的属性值与 Vue 实例中的数据进行绑定。</p><p>2.使用<code>axios</code>框架的 <code>get</code>方法请求 AJAX 并自动将数据封装进了 Vue 实例的数据对象中。</p><p>3.我们在data中的数据结构必须要和<code>Ajax</code>响应回来的数据格式匹配！</p><table><td bgcolor="#AEEEEE"></td></table><h1 id="Vue-的生命周期"><a href="#Vue-的生命周期" class="headerlink" title="Vue 的生命周期"></a>Vue 的生命周期</h1><p><strong>官方文档：</strong><a href="https://cn.vuejs.org/v2/guide/instance.html" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/instance.html</a></p><p>&emsp;&emsp;Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载DOM、渲染 –﹥更新 –﹥渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。通俗说就是 Vue 实例从创建到销毁的过程，就是生命周期。</p><p>&emsp;&emsp;在 Vue 的整个生命周期中，它提供了一系列的事件，可以让我们在事件触发时注册 JS 方法，可以让我们用自己注册的 JS 方法控制整个大局，在这些事件响应方法中的 this 直接指向的是 Vue 的实例。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200601183019264.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM2NTUzMA==,size_16,color_FFFFFF,t_70#pic_center" class="lazyload"></p><table><td bgcolor="red"></td><td bgcolor="green"></td></table>]]></content>
    
    <summary type="html">
    
      由于Vue.js是一个视图层框架，并且作者（尤雨溪）严格遵守SOC（关注度分离原则），所以Vue.js并不包含 AJAX 的通信功能，为了解决通信问题，作者单独开发了一个名为vue-resource的插件，不过在进入2.0版本以后停止了对该插件的维护并推荐了 Axios 框架。少用jQuery，因为JQuery操作Dom太频繁！
    
    </summary>
    
    
      <category term="Vue.js" scheme="http://vogos.cn/categories/Vue-js/"/>
    
    
      <category term="Vue.js" scheme="http://vogos.cn/tags/Vue-js/"/>
    
      <category term="Axios" scheme="http://vogos.cn/tags/Axios/"/>
    
  </entry>
  
  <entry>
    <title>Spring：IOC本质分析探究</title>
    <link href="http://vogos.cn/2020/07/02/Spring%EF%BC%9AIOC%E6%9C%AC%E8%B4%A8%E5%88%86%E6%9E%90%E6%8E%A2%E7%A9%B6/"/>
    <id>http://vogos.cn/2020/07/02/Spring%EF%BC%9AIOC%E6%9C%AC%E8%B4%A8%E5%88%86%E6%9E%90%E6%8E%A2%E7%A9%B6/</id>
    <published>2020-07-02T07:25:57.000Z</published>
    <updated>2020-08-01T09:47:21.982Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p><strong>官方文档：</strong> <a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#spring-core" target="_blank" rel="noopener">https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#spring-core</a></p><p><code>控制反转IOC</code>(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IOC的一种方法，也有人认为DI只是IOC的另一种说法。没有IOC的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200702151016907.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM2NTUzMA==,size_16,color_FFFFFF,t_70" class="lazyload"><br>&emsp;&emsp;IOC是Spring框架的核心内容，使用多种方式完美的实现了IOC，可以使用XML配置，也可以使用注解，新版本的Spring也可以零配置实现IoC。</p><p>&emsp;&emsp;Spring容器在初始化时先读取配置文件，根据配置文件或元数据创建与组织对象存入容器中，程序使用时再从IOC容器中取出需要的对象。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200702151051530.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM2NTUzMA==,size_16,color_FFFFFF,t_70" class="lazyload"><br>&emsp;&emsp;采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把两者合为一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。</p><p>&emsp;&emsp;<strong>控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器，其实现方法是依赖注入（Dependency Injection,DI）。</strong></p><hr><h1 id="IOC理论推导"><a href="#IOC理论推导" class="headerlink" title="IOC理论推导"></a>IOC理论推导</h1><blockquote><p>搭建项目</p></blockquote><p>&emsp;&emsp;新建Maven项目，pom.xml到导入spring-webmvc依赖(也可称为包，导该依赖的好处就是：idea会默认帮我们导入spring的几个主要包)，删除src目录，项目根目录下新建Module，并且选择maven项目（这样就可以在一个项目中，新建多个项目了(Module)）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200702151328976.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM2NTUzMA==,size_16,color_FFFFFF,t_70" class="lazyload"><br><code>原来：</code></p><ol><li>UserDao 接口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ling.dao;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 编程之外</span></span><br><span class="line"><span class="comment"> * dao接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>UserDaoImpl 实现类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ling.dao;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 编程之外</span></span><br><span class="line"><span class="comment"> * dao实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"默认获取用户的数据"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>UserService 业务接口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ling.service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 编程之外</span></span><br><span class="line"><span class="comment"> * service接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>UserServiceImpl 业务实现类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ling.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.ling.dao.UserDao;</span><br><span class="line"><span class="keyword">import</span> com.ling.dao.UserDaoImpl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 编程之外</span></span><br><span class="line"><span class="comment"> * service 实现类</span></span><br><span class="line"><span class="comment"> * service层调到层实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao = <span class="keyword">new</span> UserDaoImpl();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userDao.getUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200702151540128.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM2NTUzMA==,size_16,color_FFFFFF,t_70" class="lazyload"><br>在之前的业务中，用户的需求可能会影响我们原来的代码，我们需要根据用户的需求，去修改原代码！如果程序代码量非常大，修改一次的成本代价就十分昂贵！</p><p><strong>现在我们使用一个Set接口实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ling.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.ling.dao.UserDao;</span><br><span class="line"><span class="keyword">import</span> com.ling.dao.UserDaoImpl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 编程之外</span></span><br><span class="line"><span class="comment"> * service 实现类</span></span><br><span class="line"><span class="comment"> * service层调到层实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//利用set进行动态实现值的注入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDao</span><span class="params">(UserDao userDao)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userDao=userDao;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userDao.getUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>之前，程序是主动创建对象！控制权在程序员手上</li><li>使用了set注入后，程序不再具有主动性，而是变成了被动的接收对象！ ==控制反转==</li></ul><p><strong>这种思想从本质上解决了问题，我们不用再去管理对象的创建 。系统的耦合性大大降低~，可以更专注的在业务的实现上！</strong> 这是IOC的原型！</p><hr><h1 id="HelloSpring"><a href="#HelloSpring" class="headerlink" title="HelloSpring"></a>HelloSpring</h1><p><strong>1、编写一个HelloSpring实体类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ling.pojo;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 编程之外</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloSpring</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello"</span>+ name );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"HelloSpring&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、在resources目录下编写spring配置文件 , 这里命名为beans.xml</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--使用Spring来创建对象，在spring这些都称为Bean</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        原来：</span></span><br><span class="line"><span class="comment">             类型   变量名 = new  类型();</span></span><br><span class="line"><span class="comment">            Hello  hello = new  Hello();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        现在：</span></span><br><span class="line"><span class="comment">            bean = 对象  ==》new Hello();</span></span><br><span class="line"><span class="comment">            id = 变量名</span></span><br><span class="line"><span class="comment">            class = new 的对象;</span></span><br><span class="line"><span class="comment">            property 相对于给对象中的name属性设置一个值 -》Spring</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"hello"</span> <span class="attr">class</span>=<span class="string">"com.ling.pojo.HelloSpring"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"Spring"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>3、进行测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.ling.pojo.HelloSpring;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 编程之外</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSpring</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取spring的上下文对象！解析beans.xml文件 , 生成管理相应的Bean对象</span></span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//我们的对象现在都在spring中的管理了，要使用，直接通过id（这里的hello）去里面取出来就可以了</span></span><br><span class="line">        <span class="comment">//getBean : 参数即为spring配置文件中bean的id .</span></span><br><span class="line">        HelloSpring hello = (HelloSpring) context.getBean(<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(hello.toString());</span><br><span class="line">        hello.show();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结论：</strong></p><ul><li>HelloSpring 对象是由Spring创建的</li><li>HelloSpring  对象的属性是由Spring容器设置的 </li></ul><h2 id="上面的过程就叫控制反转"><a href="#上面的过程就叫控制反转" class="headerlink" title="上面的过程就叫控制反转 :"></a>上面的过程就叫控制反转 :</h2><p><code>控制 :</code> 谁来控制对象的创建 , 传统应用程序的对象是由程序本身控制创建的 , 使用Spring后 , 对象是由Spring来创建的 .</p><p><code>反转 : </code>程序本身不创建对象 , 而变成被动的接收对象 .</p><hr><h1 id="IOC创建对象的原理-方式"><a href="#IOC创建对象的原理-方式" class="headerlink" title="IOC创建对象的原理(方式)"></a>IOC创建对象的原理(方式)</h1><ol><li><p>使用无参构造新建对象，默认！</p></li><li><p>使用有参构造创建对象。</p><ol><li>通过参数 下标赋值</li></ol></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--通过下标赋值：下标为 0 即有参构造中的第一个参数--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"com.ling.pojo.User"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">value</span>=<span class="string">"编程之外"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>通过参数类型赋值<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--通过参数类型赋值，但如果有两个参数都是String类型，则报错，所以不建议使用该方式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"com.ling.pojo.User"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span> <span class="attr">value</span>=<span class="string">"编程之外"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>通过参数名赋值<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--通过参数名称赋值，如这里的 name参数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"com.ling.pojo.User"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"编程之外"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>总结：在配置文件加载的时候，容器中管理的对象就已经初始化了！</strong></p><hr>]]></content>
    
    <summary type="html">
    
      IOC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IOC的一种方法，也有人认为DI只是IOC的另一种说法。没有IOC的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。
    
    </summary>
    
    
      <category term="Spring" scheme="http://vogos.cn/categories/Spring/"/>
    
    
      <category term="Spring IOC" scheme="http://vogos.cn/tags/Spring-IOC/"/>
    
  </entry>
  
  <entry>
    <title>项目部署并常驻在服务器后台</title>
    <link href="http://vogos.cn/2020/05/18/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%B9%B6%E5%B8%B8%E9%A9%BB%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%8E%E5%8F%B0/"/>
    <id>http://vogos.cn/2020/05/18/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%B9%B6%E5%B8%B8%E9%A9%BB%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%8E%E5%8F%B0/</id>
    <published>2020-05-18T10:37:16.000Z</published>
    <updated>2020-08-01T14:43:59.867Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>﻿<img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200407133103120.gif#pic_center" class="lazyload"></p><table><td bgcolor="#AEEEEE"></td></table><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;上一次文章是自己的博客项目正式上线，这次分享：“怎么让自己写好的项目常驻与服务器后台！”</p><p>&emsp;&emsp;在这之前，先了解一下服务器部署项目的一些环境依赖问题。服务器部署项目时，你的项目用到了什么环境，就要在服务器上安装相应的环境依赖 ，一般常要安装的就是MySQL、JDK、Tomcat等，它们的具体安装过程在我的CSDN博客都有，这里不再详细说明啦，这三个环境一般都是Java开发的项目部署时需要安装的，还有其它一些项目，比如是用Python开发的话，你的服务器就需要再安装一个Python环境。</p><p>&emsp;&emsp;SpringBoot框架出来之前，Java开发的web项目（和Maven等项目）一直都是打war包，将打好的war包上传到你安装的Tomcat的webapps目录下，只要你的Tomcat一直是启动着的，那你的项目就随时都可以访问。</p><p>&emsp;&emsp;我的个人博客是使用的SpringBoot框架，SpringBoot它集成了Tomcat，所以部署时可以不用安装Tomcat，它打包后得到的是一个JAR包，只要安装JDK和MySQL就可以了（我没有用到Redis，反之就需要再安装Redis），但这种JAR包有一个问题就是：你关闭Xshell（我使用的是Xshell，也还有其他一些远程管理工具）后，你的项目也被关闭了，它并没有常驻服务器后台。</p><p>&emsp;&emsp;在实际中，做好的项目是需要一直常驻服务器后台的，我的这个项目就是一直常驻服务器后台，只要我的服务器没崩，输入以下网址随时都可以访问：</p><p><a href="http://vogos.cn/">http://vogos.cn/</a></p><p>&emsp;&emsp;昨天刚刚上线了3.0版本，新增了时间轴功能，修复了照片墙图片无法显示问题，欢迎小伙伴们访问啊</p><p>&emsp;&emsp;上面说了那么多废话，就当是知识科普了。下面我以具体的示例演示：使SpringBoot项目，常驻服务器后台的过程和遇到的坑。</p><hr><table><td bgcolor="blue"></td><td bgcolor="red"></td></table><table><td bgcolor="green"><font size="4px" color="white">使服务长存于服务器</font></td></table><p><strong>在你上传的项目同一级目录新建下面三个脚本内容</strong><br><strong>脚本中的 blog.jar 为打好的项目jar包</strong></p><h2 id="start-sh"><a href="#start-sh" class="headerlink" title="start.sh"></a><code>start.sh</code></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">nohup java -jar blog.jar --server.port=<span class="number">80</span> &amp;</span><br></pre></td></tr></table></figure><h2 id="stop-sh"><a href="#stop-sh" class="headerlink" title="stop.sh"></a><code>stop.sh</code></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">PID=$(ps -ef | grep blog.jar | grep -v grep | awk <span class="string">'&#123; print $2 &#125;'</span>)</span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">"$PID"</span> ]</span><br><span class="line">then</span><br><span class="line">    echo Application is already stopped</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    echo kill $PID</span><br><span class="line">    kill $PID</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h2 id="run-sh"><a href="#run-sh" class="headerlink" title="run.sh"></a><code>run.sh</code></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">echo stop application</span><br><span class="line">source stop.sh</span><br><span class="line">echo start application</span><br><span class="line">source start.sh</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;之后就可以通过./run.sh来启动和关闭项目了，这里的启动会使项目常驻与服务器后台</p><hr><table><td bgcolor="green"><font size="4px" color="white">示例</font></td><td bgcolor="#AEEEEE"></td></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 对当前目录下的所有.sh文件具有读写权限</span><br><span class="line">chmod u+x *.sh</span><br></pre></td></tr></table></figure><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200518182849951.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM2NTUzMA==,size_16,color_FFFFFF,t_70" class="lazyload"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200518182924317.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM2NTUzMA==,size_16,color_FFFFFF,t_70" class="lazyload"></p><blockquote><p>==项目部署成功==<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200518183348738.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM2NTUzMA==,size_16,color_FFFFFF,t_70" class="lazyload"></p></blockquote><p><a href="http://vogos.cn/">http://vogos.cn</a><br>关掉Xshell，测试访问成功！<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200518183440624.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM2NTUzMA==,size_16,color_FFFFFF,t_70" class="lazyload"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200408141514825.gif#pic_center" class="lazyload"></p><table><td bgcolor="green"></td><td bgcolor="red"></td></table>]]></content>
    
    <summary type="html">
    
      服务器部署项目时，你的项目用到了什么环境，就要在服务器上安装相应的环境依赖 ，一般常要安装的就是MySQL、JDK、Tomcat等，它们的具体安装过程在我的CSDN博客都有，这里不再详细说明啦，这三个环境一般都是Java开发的项目部署时需要安装的，还有其它一些项目，比如是用Python开发的话，你的服务器就需要再安装一个Python环境。
    
    </summary>
    
    
      <category term="服务器" scheme="http://vogos.cn/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="Linux" scheme="http://vogos.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Java适配器模式详解</title>
    <link href="http://vogos.cn/2020/04/16/Java%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>http://vogos.cn/2020/04/16/Java%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-04-16T07:27:09.000Z</published>
    <updated>2020-08-03T03:04:04.577Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200407133103120.gif#pic_center" class="lazyload"></p><h1 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h1><p>==设计模式分为三种类型，共23种：这里先暂时只分享<strong>适配器模式</strong>的学习==</p><ul><li><strong>创建型模式</strong>：<a href="https://link.jianshu.com/?t=https://github.com/youlookwhat/DesignPattern#3-%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">单例模式</a>、抽象工厂模式、建造者模式、<a href="https://link.jianshu.com/?t=https://github.com/youlookwhat/DesignPattern#2-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">工厂模式</a>、原型模式。</li><li><strong>结构型模式</strong>：<a href="https://link.jianshu.com/?t=https://github.com/youlookwhat/DesignPattern#5-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">适配器模式</a>、桥接模式、<a href="https://link.jianshu.com/?t=https://github.com/youlookwhat/DesignPattern#7-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">装饰模式</a>、组合模式、<a href="https://link.jianshu.com/?t=https://github.com/youlookwhat/DesignPattern#8-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">外观模式</a>、享元模式、代理模式。</li><li><strong>行为型模式</strong>：<a href="https://link.jianshu.com/?t=https://github.com/youlookwhat/DesignPattern#9-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">模版方法模式</a>、<a href="https://link.jianshu.com/?t=https://github.com/youlookwhat/DesignPattern#6-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">命令模式</a>、迭代器模式、<a href="https://link.jianshu.com/?t=https://github.com/youlookwhat/DesignPattern#1-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">观察者模式</a>、中介者模式、备忘录模式、解释器模式、<a href="https://link.jianshu.com/?t=https://github.com/youlookwhat/DesignPattern#10-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">状态模式</a>、<a href="https://link.jianshu.com/?t=https://github.com/youlookwhat/DesignPattern#4-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">策略模式</a>、职责链模式(责任链模式)、访问者模式。</li></ul><table><td bgcolor="#AEEEEE"></td></table><hr><h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><p>&emsp;&emsp;在应用程序中，我们可能需要让两个不同接口的类来进行通信，在不修改这两个的前提下我们可能会需要某个中间件来完成这个衔接的过程。这个中间件就是适配器。</p><blockquote><p><strong>适配器模式定义：将一个类的接口转换成客户期望的另一个接口，适配器(Adapter)让原本接口不兼容的类可以相互合作。</strong></p></blockquote><hr><table><td bgcolor="#AEEEEE"></td></table><h2 id="实例"><a href="#实例" class="headerlink" title="实例:"></a><code>实例:</code></h2><p>&emsp;&emsp;现在市面上的笔记本电脑越来越薄，很多电脑就去掉了传统的那种网线接口，是插不了网线的。要插网线就需要通过USB网线转化器来实现，这里就有一些适配器的思想体现了。</p><ul><li><strong>USB网线转换器：一端连接电脑，另一端连接网线</strong><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200416151152871.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM2NTUzMA==,size_16,color_FFFFFF,t_70" class="lazyload"><table><td bgcolor="#AEEEEE"></td></table></li></ul><hr><p><code>角色分析：</code></p><p><strong>目标接口：</strong> 客户所期待的接口，目标可以是具体的或抽象的类，也可以是接口。(这里的电脑接口)</p><p><strong>需要适配的类：</strong> 需要适配的类或适配者类。(网线)</p><p><strong>适配器：</strong> 通过包装一个需要适配的对象，把原接口转换成目标对象！（USB网线转换器）</p><hr><p>==三个类：网线，适配器，电脑==</p><p><code>网线抽象建模：</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> adapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">//要被适配的类：(这里的网线抽象)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reticle</span> </span>&#123;</span><br><span class="line">    <span class="comment">//它(网线)的功能 --&gt; 上网</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"成功连接网线上网了！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><td bgcolor="#AEEEEE"></td></table><p><code>适配器抽象建模：</code></p><p><strong>==第一种方法：==</strong> 类适配器，这种方法是通过继承Reticle去实现的，但Java是单继承的，Adapter类只能去适配一个东西，实际开发中相对不适用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> adapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体的实现类：(真正的适配器) 需要连接电脑端的USB接口，连接网线</span></span><br><span class="line"><span class="comment"> * 1.这个适配器需要去实现 NetToUsb 接口(重写接口的方法)，这个接口最后会被[笔记本]电脑去处理</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2.适配器需要去处理上网的请求，而上网真正是在网线上的，所以，适配器去继承Reticle(网线)即可</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Reticle</span> <span class="keyword">implements</span> <span class="title">NetToUsb</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Adapter 的父类(Reticle)去调用上网的方法</span></span><br><span class="line">        <span class="keyword">super</span>.request(); <span class="comment">//可以上网了~</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>==第二种方法：==</strong> 对象适配器，通过组合来实现(常用)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> adapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.通过组合实现--》对象适配器(常用)</span></span><br><span class="line"><span class="comment">//接入网线</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter2</span>  <span class="keyword">implements</span> <span class="title">NetToUsb</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//网线私有，将网线组合进来</span></span><br><span class="line">    <span class="keyword">private</span> Reticle reticle;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Adapter2</span><span class="params">(Reticle reticle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.reticle = reticle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//直接调用Reticle的实现方法即可</span></span><br><span class="line">        reticle.request(); <span class="comment">//可以上网了~</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>==<strong>适配器抽象为接口：</strong>==</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> adapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 模拟接口转换器的接口，接口转换器的抽象实现~</span></span><br><span class="line"><span class="comment">* 通过实现这个接口，得到多个转换器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NetToUsb</span> </span>&#123;</span><br><span class="line">    <span class="comment">//作用:处理请求(将网线=&gt;usb)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><td bgcolor="#AEEEEE"></td></table><p><code>电脑抽象建模：</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> adapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端类：(电脑的抽象~)  想上网,但插不了网线</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 电脑想要上网这个事件，对应一个抽象方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 电脑需要连接上转接器才可以上网，so，就给它传一个转接器的接口</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="comment">//上网的具体实现方法~</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">net</span><span class="params">(NetToUsb adapter)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 需要一个转接头(参数)去调用具体实现类的方法来处理上网的请求</span></span><br><span class="line">        adapter.handleRequest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//真实上网</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//需要电脑，网线，适配器~</span></span><br><span class="line">        Computer computer = <span class="keyword">new</span> Computer();</span><br><span class="line">        Reticle reticle = <span class="keyword">new</span> Reticle();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.这种适配器是通过继承Reticle去实现的--》类适配器，</span></span><br><span class="line">        Adapter adapter = <span class="keyword">new</span> Adapter();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.通过组合去实现--》对象适配器(常用)</span></span><br><span class="line">        Adapter2 adapter2 = <span class="keyword">new</span> Adapter2(reticle);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.调用上网的具体实现方法，给它一个转接器即可上网</span></span><br><span class="line">        <span class="comment">//该方法：适配器已经继承了Reticle(网线)了---》使得适配器自带上网功能</span></span><br><span class="line">        computer.net(adapter);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.组合实现，先插网线再接电脑</span></span><br><span class="line">        computer.net(adapter2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><table><td bgcolor="#AEEEEE"></td></table><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>&emsp;&emsp;Computer(电脑)类 和 Reticle(网线)类没有任何关系，通过适配器将它们联系起来，从而实现了电脑上网<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200416151545922.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM2NTUzMA==,size_16,color_FFFFFF,t_70" class="lazyload"></p><hr><p><code>◆对象适配器优点</code></p><ul><li>一个对象适配器可以把多个不同的适配者适配到同一个目标</li><li>可以适配一个适配者的子类，由于适配器和适配者之间是关联关系，根据<code>“里氏代换原则”</code>，适配者<br>的子类也可通过该适配器进行适配。</li></ul><hr><p><code>◆类适配器缺点</code></p><ul><li>对于ava、C#等不支持多重类继承的语言，一次最多只能适配一个适配者类，不能同时适配多个适配者;</li><li>在ava、C#等语言中，类适配器模式中的目标抽象类只能为接口，不能为类，其使用有一定的局限性。</li></ul><hr><p><code>◆适用场景</code></p><ul><li>系统需要使用一些现有的类，而这些类的接口(如方法名)不符合系统的需要，甚至没有这些类的源<br>代码。</li><li>想创建一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引<br>进的类一起工作。</li></ul><hr><table><td bgcolor="#AEEEEE"></td></table><h1 id="编程之外"><a href="#编程之外" class="headerlink" title="编程之外"></a>编程之外</h1><p>&emsp;&emsp;<strong>学好设计模式，给世界进行更好的建模！</strong> 欢迎小伙伴入坑公众号 <strong>编程之外</strong>，学习更多的编程知识，寻找编程之外的乐趣，互相监督一起成长！😁😁可在公众号回复 ==<strong>pdf</strong>== ，获取Java学习和面试的资料！<img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200408141514825.gif#pic_center" class="lazyload"></p><table><td bgcolor="green"><font size="3px" color="green">编程之外</font></td></table>]]></content>
    
    <summary type="html">
    
      在应用程序中，我们可能需要让两个不同接口的类来进行通信，在不修改这两个的前提下我们可能会需要某个中间件来完成这个衔接的过程。这个中间件就是适配器。适配器模式定义：将一个类的接口转换成客户期望的另一个接口，适配器(Adapter)让原本接口不兼容的类可以相互合作。
    
    </summary>
    
    
      <category term="Java基础" scheme="http://vogos.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="http://vogos.cn/tags/Java/"/>
    
      <category term="设计模式" scheme="http://vogos.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="适配器模式" scheme="http://vogos.cn/tags/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>﻿Java多线程详解+案例演示</title>
    <link href="http://vogos.cn/2020/03/10/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3+%E6%A1%88%E4%BE%8B%E6%BC%94%E7%A4%BA/"/>
    <id>http://vogos.cn/2020/03/10/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3+%E6%A1%88%E4%BE%8B%E6%BC%94%E7%A4%BA/</id>
    <published>2020-03-10T15:27:36.000Z</published>
    <updated>2020-08-01T14:59:11.695Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><hr><h1 id="程序-进程-线程"><a href="#程序-进程-线程" class="headerlink" title="程序.进程.线程"></a>程序.进程.线程</h1><p><strong>在操作系统中运行的==程序==就是==进程==，例如微信、IDE、QQ等(暴露年龄了🤐)</strong></p><p><strong>一个进程中可以存在多个线程，如播放一个视频时有声音、图像、文字等等</strong></p><hr><h1 id="Process与Thread"><a href="#Process与Thread" class="headerlink" title="Process与Thread"></a>Process与Thread</h1><ul><li>==程序==是指令和数据的有序集合，其本身没有任何运行的含义，只是一个静态的概念。</li><li>==进程==是执行程序的一次执行过程，是一个动态的概念。是系统资源分配的单位。</li><li>通常在一个==进程==中可以包含若干个==线程==，一个进程中至少有一个线程（main），不然没有存在的意义。线程是CPU调度和执行的单位。</li></ul><hr><h1 id="普通方法调用和多线程图解"><a href="#普通方法调用和多线程图解" class="headerlink" title="普通方法调用和多线程图解"></a>普通方法调用和多线程图解</h1><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2020031016403990.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM2NTUzMA==,size_16,color_FFFFFF,t_70" class="lazyload"></p><hr><h1 id="线程的三种创建方式"><a href="#线程的三种创建方式" class="headerlink" title="线程的三种创建方式"></a>线程的三种创建方式</h1><ul><li><strong>继承Thread类（※※）</strong></li><li><strong>实现Runnable接口（※※※）</strong></li><li><strong>实现Callable接口（※）</strong></li></ul><hr><h2 id="一、继承Thread类的实现（※※）"><a href="#一、继承Thread类的实现（※※）" class="headerlink" title="一、继承Thread类的实现（※※）"></a>一、继承Thread类的实现（※※）</h2><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><p>如下，JDK帮助文档中关于==Thread==类的使用介绍<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200310172138836.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM2NTUzMA==,size_16,color_FFFFFF,t_70" class="lazyload"><br>（PS：需要这个中文版JDK帮助文档的，可到网盘自行下载。网盘容易被墙，失效了可以评论让我分享）<br><strong>网盘链接：</strong><a href="https://pan.baidu.com/s/1tFMqo7B5Umd439nnU9LhyQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1tFMqo7B5Umd439nnU9LhyQ</a>      提取码：s6c4</p><p>使用==继承Thread类==实现多线程，根据JDK帮助文档主要有以下三个步骤：</p><ol><li>自定义一个类去继承==Thread类==。</li><li>重写==run()== 方法，编写线程执行体。</li><li>创建线程对象，调用==start()== 方法启动线程</li></ol><hr><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.thread;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建线程方式一：继承Thread类，重写run()方法，调用start开启线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//super.run();</span></span><br><span class="line">        <span class="comment">//run方法线程体</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"run方法线程体----"</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 两个线程是同时执行的</span></span><br><span class="line"><span class="comment">     * 注意：线程开启不一定立即执行，由CPU调度执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//main方法，主线程</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个线程对象</span></span><br><span class="line">        TestThread1 thread1 = <span class="keyword">new</span> TestThread1();</span><br><span class="line">        <span class="comment">//调用start()方法开启线程</span></span><br><span class="line">        thread1.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"main方法，主线程----"</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="案例应用"><a href="#案例应用" class="headerlink" title="案例应用"></a>案例应用</h3><p> 多线程同步下载图片：利用多线程来下载网络图片。这里我使用的是<strong>apache的commons.io包中FileUtils文件工具类</strong>，使用FileUtils文件工具类下的==copyURLToFile方法==，接收一个url地址即可下载网络图片</p><hr><p><strong><em>注意：</em></strong> commons.io包需要去apache官网下载，然后将下载的jar包放入==lib目录(包)中==，并右击lib包，选择Add  as  Library将lib中的jar包添加到Library中<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200310184018781.png" class="lazyload"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200310184323693.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM2NTUzMA==,size_16,color_FFFFFF,t_70" class="lazyload"></p><hr><p> 定义一个WebDownloader类作为下载器。如下，查看copyURLToFile()方法的源码实现可发现，copyURLToFile方法至少需要传入一个url地址参数，并且需要抛出一个IOException异常</p><p> <img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200310180817534.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM2NTUzMA==,size_16,color_FFFFFF,t_70" class="lazyload"></p><hr><p> 在下载器中定义一个downloader方法，接收两个参数（url地址和文件名），并使用copyURLToFile来下载传入的地址中的文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebDownloader</span></span>&#123;</span><br><span class="line">    <span class="comment">//下载方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">downloader</span><span class="params">(String url,String name)</span></span>&#123;</span><br><span class="line">        <span class="comment">//FileUtils工具类中的copyURLToFile方法，copy网页文件（URL地址变成文件）</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileUtils.copyURLToFile(<span class="keyword">new</span> URL(url),<span class="keyword">new</span> File(name));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">"IO异常，downloader方法出现问题！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>在TestThread2继承类中，定义两个私有属性，分别保存url地址和文件名，并用构造器给两个属性赋值。继承了==Thread==类，还需要在TestThread2类中重写run方法，在run方法中即可编写下载文件线程的执行体(调用下载器中的downloader方法下载文件)</p><p>然后，便可在main主线程中创建多个线程对象 ，调用对应的start()方法启动线程了~<br>（描述过于繁杂，也可以直接看代码中简洁的注释，我主要是想写博客时再加深一下自己的记忆🤣🤣）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继承Thread类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String url;<span class="comment">//网络图片地址</span></span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">//保存的文件名</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器(构造方法) Alt + Insert</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestThread2</span><span class="params">(String url, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写run方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;<span class="comment">//下载图片线程的执行体</span></span><br><span class="line">        <span class="comment">//新建WebDownloader(下载器)对象</span></span><br><span class="line">        WebDownloader webDownloader = <span class="keyword">new</span> WebDownloader();</span><br><span class="line">        <span class="comment">//调用webDownloader中的downloader方法并传入相应参数  下载文件</span></span><br><span class="line">        webDownloader.downloader(url,name);</span><br><span class="line">        System.out.println(<span class="string">"下载了文件名为："</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建三个该线程对象       （传入构造方法的参数）</span></span><br><span class="line">        TestThread2 Thread1 = <span class="keyword">new</span> TestThread2(<span class="string">"https://dss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=3173584241,3533290860&amp;fm=26&amp;gp=0.jpg"</span>,<span class="string">"tupian1.jpg"</span>);</span><br><span class="line">        TestThread2 Thread2 = <span class="keyword">new</span> TestThread2(<span class="string">"https://dss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=1906469856,4113625838&amp;fm=26&amp;gp=0.jpg"</span>,<span class="string">"tupian2.jpg"</span>);</span><br><span class="line">        TestThread2 Thread3 = <span class="keyword">new</span> TestThread2(<span class="string">"https://dss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=1208538952,1443328523&amp;fm=26&amp;gp=0.jpg"</span>,<span class="string">"tupian3.jpg"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//主函数中调用start()方法开启三个线程</span></span><br><span class="line">        <span class="comment">// 每次运行三个线程下载图片顺序都不一样（即启动线程不一定立即执行，由CPU安排调度）</span></span><br><span class="line">        Thread1.start();</span><br><span class="line">        Thread2.start();</span><br><span class="line">        Thread3.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="完整代码实现"><a href="#完整代码实现" class="headerlink" title="完整代码实现"></a>完整代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.thread;</span><br><span class="line"></span><br><span class="line"><span class="comment">//apache的commons.io包，FileUtils文件工具类</span></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.FileUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"></span><br><span class="line"><span class="comment">//练习Thread，实现多线程同步下载图片</span></span><br><span class="line"><span class="comment">//继承Thread类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String url;<span class="comment">//网络图片地址</span></span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">//保存的文件名</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器(构造方法) Alt + Insert</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestThread2</span><span class="params">(String url, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写run方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;<span class="comment">//下载图片线程的执行体</span></span><br><span class="line">        <span class="comment">//新建WebDownloader(下载器)对象</span></span><br><span class="line">        WebDownloader webDownloader = <span class="keyword">new</span> WebDownloader();</span><br><span class="line">        <span class="comment">//调用webDownloader中的downloader方法并传入相应参数  下载文件</span></span><br><span class="line">        webDownloader.downloader(url,name);</span><br><span class="line">        System.out.println(<span class="string">"下载了文件名为："</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建三个该线程对象       （传入构造方法的参数）</span></span><br><span class="line">        TestThread2 Thread1 = <span class="keyword">new</span> TestThread2(<span class="string">"https://dss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=3173584241,3533290860&amp;fm=26&amp;gp=0.jpg"</span>,<span class="string">"tupian1.jpg"</span>);</span><br><span class="line">        TestThread2 Thread2 = <span class="keyword">new</span> TestThread2(<span class="string">"https://dss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=1906469856,4113625838&amp;fm=26&amp;gp=0.jpg"</span>,<span class="string">"tupian2.jpg"</span>);</span><br><span class="line">        TestThread2 Thread3 = <span class="keyword">new</span> TestThread2(<span class="string">"https://dss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=1208538952,1443328523&amp;fm=26&amp;gp=0.jpg"</span>,<span class="string">"tupian3.jpg"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//主函数中调用start()方法开启三个线程</span></span><br><span class="line">        <span class="comment">// 每次运行三个线程下载图片顺序都不一样（即启动线程不一定立即执行，由CPU安排调度）</span></span><br><span class="line">        Thread1.start();</span><br><span class="line">        Thread2.start();</span><br><span class="line">        Thread3.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下载器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebDownloader</span></span>&#123;</span><br><span class="line">    <span class="comment">//下载方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">downloader</span><span class="params">(String url,String name)</span></span>&#123;</span><br><span class="line">        <span class="comment">//FileUtils工具类中的copyURLToFile方法，copy网页文件（URL地址变成文件）</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileUtils.copyURLToFile(<span class="keyword">new</span> URL(url),<span class="keyword">new</span> File(name));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">"IO异常，downloader方法出现问题！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><hr><h2 id="二、实现Runnable接口（※※※）"><a href="#二、实现Runnable接口（※※※）" class="headerlink" title="二、实现Runnable接口（※※※）"></a>二、实现Runnable接口（※※※）</h2><p>如下，查看官方JDK帮助文档==实现Runnable接口==与==Thread==类的使用两种方式实现多线程差别不大<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2020031018551648.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM2NTUzMA==,size_16,color_FFFFFF,t_70" class="lazyload"><br><strong>概括就是：实现runnable接口，重写run方法，执行线程需要丢入runnable接口实现类，调用start方法</strong></p><hr><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>和继承Thread的差别只是==implements Runnable==和开启线程时需要丢入runnable接口的实现类   ==new Thread(testThread3).start();==</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.thread;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建线程方式2：实现runnable接口，重写run方法，执行线程需要丢入runnable接口实现类，调用start方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread3</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//super.run();</span></span><br><span class="line">        <span class="comment">//run方法线程体</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"run方法线程体----"</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 两个线程是同时执行的</span></span><br><span class="line"><span class="comment">     * 注意：线程开启不一定立即执行，由CPU调度执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建runnable接口的实现类对象</span></span><br><span class="line">        TestThread3 testThread3 = <span class="keyword">new</span> TestThread3();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建线程对象，通过线程对象来开启线程（代理）</span></span><br><span class="line">        <span class="comment">//Thread thread = new Thread(testThread3);//丢入rnnnable接口实现类</span></span><br><span class="line">        <span class="comment">//thread.start();</span></span><br><span class="line">        <span class="comment">//上面两句可简写为</span></span><br><span class="line">        <span class="keyword">new</span> Thread(testThread3).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"main方法，主线程----"</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="案例应用-1"><a href="#案例应用-1" class="headerlink" title="案例应用"></a>案例应用</h3><p>如下，使用”继承Thread类”的同一个案例，只是两个地方有所不同<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200310192114920.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM2NTUzMA==,size_16,color_FFFFFF,t_70" class="lazyload"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200310192302450.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM2NTUzMA==,size_16,color_FFFFFF,t_70" class="lazyload"></p><hr><hr><h1 id="两种方式实现多线程小结"><a href="#两种方式实现多线程小结" class="headerlink" title="两种方式实现多线程小结"></a>两种方式实现多线程小结</h1><p><strong><em>继承Thread类：</em></strong></p><ul><li>子类继承Thread类具备多线程能力</li><li>启动线程：==<strong>子类对象 . start()</strong>==</li><li>不建议使用：避免OOP单继承的局限性</li></ul><hr><p><strong><em>实现Runnable接口：</em></strong></p><ul><li>实现接口Runnable具有多线程能力</li><li>启动线程：**==传入目标对象+Thread对象 . start()==**</li><li>推荐使用：避免了单继承的局限性，方便同一个对象被多个线程使用</li></ul><hr><hr><h1 id="拓展案例"><a href="#拓展案例" class="headerlink" title="拓展案例"></a>拓展案例</h1><p>==多线程同时操作同一个对象==<br><strong><em>案例：</em></strong> 买火车票的例子，一共有10张火车票，三个人（三个线程）同时去抢这10张火车票，输出这三个人分别抢了哪几张票？</p><hr><p><strong><em>思路：</em></strong> 创建一个线程对象，实现Runnable接口，重写了run方法（线程体中：总数10张票，每拿一张票就减减，小于1就跳出循环），三个线程都在用这10张票，每个人都会进去拿</p><hr><p><strong><em>代码实现：</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.thread;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多线程同时操作同一个对象</span></span><br><span class="line"><span class="comment">//买火车票的例子</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread4</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//票数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticketNums = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (ticketNums&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//模拟延时，否则CPU运行太快10张票全被一个线程拿了</span></span><br><span class="line">            <span class="keyword">try</span> &#123;<span class="comment">//需要捕获一个异常</span></span><br><span class="line">                Thread.sleep(<span class="number">200</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Thread.currentThread().getName():获得当前执行线程的名字</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"--&gt;拿到了第"</span>+ticketNums--+<span class="string">"张票"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        TestThread4 ticket = <span class="keyword">new</span> TestThread4();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(ticket,<span class="string">"小明"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(ticket,<span class="string">"老师"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(ticket,<span class="string">"黄牛党"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong><em>运行结果</em></strong><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200310210626998.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM2NTUzMA==,size_16,color_FFFFFF,t_70" class="lazyload"></p><p><strong>这时会有一个问题，不同的线程拿到了同一张票</strong></p><hr><p><strong>发现问题：多个线程操作同一个资源的情况下，线程不安全，数据紊乱</strong><br>这是并发问题，后面再出博客讲解这个</p><hr><hr><h2 id="三、实现Callable接口"><a href="#三、实现Callable接口" class="headerlink" title="三、实现Callable接口"></a>三、实现Callable接口</h2><p><strong><em>实现步骤：</em></strong></p><ul><li>实现Callable接口，需要返回值类型</li><li>重写call方法，需要抛出异常</li><li>创建目标对象</li><li>创建执行服务：ExecutorService ser = Executors.newFixedThreadPool(3);</li><li>提交执行：Future<boolean> r1 = ser.submit(T1);</boolean></li><li>获取结果：Boolean rs1 = r1.get();</li><li>关闭服务：ser.shutdownNow();</li></ul><hr><p><strong>实现Callable接口方法，用的很少不是重点，这里不在具体赘述了</strong></p><hr><h3 id="案例应用-2"><a href="#案例应用-2" class="headerlink" title="案例应用"></a>案例应用</h3><p>还是使用下载网络文件的案例，注意与==继承Thread类==和==实现Runnable接口==两种方式的区别即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.thread.callable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.FileUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程创建方式三：实现Callable接口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Callable的好处：</span></span><br><span class="line"><span class="comment"> * 1.可以定义返回值</span></span><br><span class="line"><span class="comment"> * 2.可以抛出异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Boolean</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String url;<span class="comment">//网络图片地址</span></span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">//保存的文件名</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器(构造方法) Alt + Insert</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestCallable</span><span class="params">(String url, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写run方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">()</span> </span>&#123;<span class="comment">//下载图片线程的执行体</span></span><br><span class="line">        WebDown webDown = <span class="keyword">new</span> WebDown();</span><br><span class="line">        webDown.downloader(url,name);</span><br><span class="line">        System.out.println(<span class="string">"下载了文件名为："</span>+name);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//创建三个该线程对象       （传入构造方法的参数）</span></span><br><span class="line">        TestCallable T1 = <span class="keyword">new</span> TestCallable(<span class="string">"https://dss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=3173584241,3533290860&amp;fm=26&amp;gp=0.jpg"</span>,<span class="string">"tupian1.jpg"</span>);</span><br><span class="line">        TestCallable T2 = <span class="keyword">new</span> TestCallable(<span class="string">"https://dss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=1906469856,4113625838&amp;fm=26&amp;gp=0.jpg"</span>,<span class="string">"tupian2.jpg"</span>);</span><br><span class="line">        TestCallable T3 = <span class="keyword">new</span> TestCallable(<span class="string">"https://dss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=1208538952,1443328523&amp;fm=26&amp;gp=0.jpg"</span>,<span class="string">"tupian3.jpg"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建执行服务</span></span><br><span class="line">        ExecutorService ser = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//提交执行</span></span><br><span class="line">        Future&lt;Boolean&gt; r1 = ser.submit(T1);</span><br><span class="line">        Future&lt;Boolean&gt; r2 = ser.submit(T2);</span><br><span class="line">        Future&lt;Boolean&gt; r3 = ser.submit(T3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取结果</span></span><br><span class="line">        Boolean rs1 = r1.get();</span><br><span class="line">        Boolean rs2 = r2.get();</span><br><span class="line">        Boolean rs3 = r3.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭服务</span></span><br><span class="line">        ser.shutdownNow();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下载器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebDown</span></span>&#123;</span><br><span class="line">    <span class="comment">//下载方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">downloader</span><span class="params">(String url,String name)</span></span>&#123;</span><br><span class="line">        <span class="comment">//FileUtils工具类中的copyURLToFile方法，copy网页文件（URL地址变成文件）</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileUtils.copyURLToFile(<span class="keyword">new</span> URL(url),<span class="keyword">new</span> File(name));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">"IO异常，downloader方法出现问题！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><hr><h1 id="上期回顾"><a href="#上期回顾" class="headerlink" title="上期回顾"></a>上期回顾</h1><p><a href="https://blog.csdn.net/weixin_42365530/article/details/104762544" target="_blank" rel="noopener">java中的接口定义与实现</a></p><hr><h1 id="关于博主"><a href="#关于博主" class="headerlink" title="关于博主"></a>关于博主</h1><p>为了让结尾好看一点…..🙄🙄🙄<br>今天就到这了，已经快凌晨十二点了🥱，再不休息我担心明天早上，又会出现一股神秘的东方力量让我赖床了！</p>]]></content>
    
    <summary type="html">
    
      1.程序是指令和数据的有序集合，其本身没有任何运行的含义，只是一个静态的概念。2.进程是执行程序的一次执行过程，是一个动态的概念。是系统资源分配的单位。3.通常在一个进程中可以包含若干个==线程==，一个进程中至少有一个线程（main），不然没有存在的意义。线程是CPU调度和执行的单位。
    
    </summary>
    
    
      <category term="Java基础" scheme="http://vogos.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="http://vogos.cn/tags/Java/"/>
    
      <category term="多线程" scheme="http://vogos.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>﻿Java中的接口定义与实现</title>
    <link href="http://vogos.cn/2020/03/09/Java%E4%B8%AD%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <id>http://vogos.cn/2020/03/09/Java%E4%B8%AD%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-03-09T14:10:36.000Z</published>
    <updated>2020-08-01T15:11:08.059Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>﻿# 接口的定义</p><p>接口就是规范，定义的是一组规则，体现了现实世界中“如果你是…则必须能…”的思想。接口的本质是契约，就像法律法规一样，制定好了都要遵守。<br>OO的精髓是对对象的抽象，最能体现这一点的就是接口。为什么我们讨论设计模式都只针对具备了抽象能力的语言（如c++、java、c#等），是因为设计模式所研究的，实际上就是如何合理的去抽象。</p><hr><p>==在Java中声明类的关键字是class，声明接口的关键字是<strong>interface</strong>==</p><hr><h1 id="接口的作用："><a href="#接口的作用：" class="headerlink" title="接口的作用："></a>接口的作用：</h1><ol><li>约束</li><li>定义一些方法，让不同的人去实现</li><li>接口中所有定义的方法都是抽象的 public abstract</li><li>常量都是 public static final</li><li>接口不能被实例化~，接口中没有构造方法</li><li>implements可以实现多个接口</li><li>必须要重写接口中的方法~</li></ol><hr><h1 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h1><ul><li>实现单个接口<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2020030922054091.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM2NTUzMA==,size_16,color_FFFFFF,t_70" class="lazyload"></li></ul><hr><p><strong>==利用接口实现多继承==</strong></p><p><strong>UserService 接口类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oop.demo07;</span><br><span class="line"></span><br><span class="line"><span class="comment">//interface  接口(定义的关键字)，接口都需要有实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="comment">//接口中所有的定义其实都是抽象的 public abstract</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(String name)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(String name)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(String name)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>TimeService 接口类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oop.demo07;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TimeService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">time</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>UserServiceImpl –&gt;两个接口的实现类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oop.demo07;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类 可以实现接口 通过 implements 接口</span></span><br><span class="line"><span class="comment">//实现了接口的类，就需要重写接口中的方法~</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//多继承~ 利用接口实现多继承</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span>,<span class="title">TimeService</span> </span>&#123;</span><br><span class="line">    <span class="comment">//接口的实现类</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写接口类中的四个方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//另一个接口中的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">time</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      接口就是规范，定义的是一组规则，体现了现实世界中“如果你是...则必须能...”的思想。接口的本质是契约，就像法律法规一样，制定好了都要遵守。OO的精髓是对对象的抽象，最能体现这一点的就是接口。为什么我们讨论设计模式都只针对具备了抽象能力的语言（如c++、java、c#等），是因为设计模式所研究的，实际上就是如何合理的去抽象。
    
    </summary>
    
    
      <category term="Java基础" scheme="http://vogos.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="http://vogos.cn/tags/Java/"/>
    
      <category term="接口" scheme="http://vogos.cn/tags/%E6%8E%A5%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>﻿Java中的方法重载</title>
    <link href="http://vogos.cn/2020/03/08/Java%E4%B8%AD%E4%BB%80%E4%B9%88%E6%98%AF%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD/"/>
    <id>http://vogos.cn/2020/03/08/Java%E4%B8%AD%E4%BB%80%E4%B9%88%E6%98%AF%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD/</id>
    <published>2020-03-08T09:39:27.000Z</published>
    <updated>2020-08-01T15:17:30.584Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>﻿# 方法的重载</p><hr><h2 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h2><p>Java中方法的重载，就是在一个类中，有相同的方法名称，但形参不同的方法。</p><hr><h2 id="方法重载的规则"><a href="#方法重载的规则" class="headerlink" title="方法重载的规则"></a>方法重载的规则</h2><ul><li>方法名称<strong>必须相同</strong></li><li>参数列表<strong>必须不同</strong>（参数个数不同、或参数类型不同、参数排列顺序不同等）。</li><li>方法的返回类型可以相同也可以不相同。</li><li>仅仅返回类型不同，不足以称为方法的重载。</li><li><strong><em>同一个类中，不允许两个方法的方法名称和参数列表都相同</em></strong></li></ul><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>如下，代码中定义了三个<strong>max</strong>方法(即<strong>方法重载</strong>)，在调用它们时根据传入的实参类型和实参个数，分别调用了对应的 max 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mJane.method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//传入的实参为3个整型数据，匹配到第一个max方法</span></span><br><span class="line">        <span class="keyword">int</span> max_value1 = max(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">        System.out.println(max_value1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//传入的实参为3个整型数据，匹配到第二个max方法，而不是第一个</span></span><br><span class="line">        <span class="keyword">int</span> max_value2 = max(<span class="number">10</span>,<span class="number">25</span>,<span class="number">7</span>);</span><br><span class="line">        System.out.println(max_value2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//传入的实参为2个浮点数，匹配到第三个max方法</span></span><br><span class="line"><span class="comment">//        int max_value3 = (int)max(10.0,30.0);   //返回值类型为double， 高--&gt;低 : 强制转换</span></span><br><span class="line">        <span class="keyword">double</span> max_value3 = max(<span class="number">10.0</span>,<span class="number">30.0</span>);</span><br><span class="line">        System.out.println(max_value3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (num1==num2)&#123;</span><br><span class="line">            System.out.println(<span class="string">"num1==num2"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//终止该方法</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num1&gt;num2)&#123;</span><br><span class="line">            result = num1;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            result = num2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//##################注释分割线#################</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2,<span class="keyword">int</span> num3)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (num1&gt;num2)&#123;</span><br><span class="line">            result = num1;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            result = num2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result &gt; num3 ? result:num3;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//##################注释分割线#################</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">max</span><span class="params">(<span class="keyword">double</span> num1,<span class="keyword">double</span> num2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span> result = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">if</span> (num1==num2)&#123;</span><br><span class="line">            System.out.println(<span class="string">"num1==num2"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//终止该方法</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num1&gt;num2)&#123;</span><br><span class="line">            result = num1;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            result = num2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>方法名相同时，编译器会根据调用方法的参数个数、参数类型等去逐个匹配，以选择对应的方法执行，如果匹配失败(未找到对应方法)，则编译器报错。</p>]]></content>
    
    <summary type="html">
    
      Java中方法的重载，就是在一个类中，有相同的方法名称，但形参不同的方法。重载的规则：方法名称**必须相同**参数列表**必须不同**（参数个数不同、或参数类型不同、参数排列顺序不同等）。
    
    </summary>
    
    
      <category term="Java基础" scheme="http://vogos.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="http://vogos.cn/tags/Java/"/>
    
      <category term="方法重载" scheme="http://vogos.cn/tags/%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>Java中的数组与集合</title>
    <link href="http://vogos.cn/2020/02/13/Java%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84%E4%B8%8E%E9%9B%86%E5%90%88/"/>
    <id>http://vogos.cn/2020/02/13/Java%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84%E4%B8%8E%E9%9B%86%E5%90%88/</id>
    <published>2020-02-13T13:19:37.000Z</published>
    <updated>2020-08-02T05:43:00.714Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>参考(整理)于：<a href="https://www.runoob.com/java/java-array.html" target="_blank" rel="noopener">https://www.runoob.com/java/java-array.html</a></p><h3 id="Java数组"><a href="#Java数组" class="headerlink" title="Java数组"></a>Java数组</h3><p>在Java 语言中数组是用来存储<strong>固定大小</strong>的同类型元素。</p><p><strong>声明数组变量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dataType[] arrayRefVar;   <span class="comment">// 首选的方法</span></span><br><span class="line">或</span><br><span class="line">dataType arrayRefVar[];  <span class="comment">// 效果相同，但不是首选方法</span></span><br></pre></td></tr></table></figure><p>注意: 建议使用 dataType[] arrayRefVar 的声明风格声明数组变量。 dataType arrayRefVar[] 风格是来自 C/C++ 语言</p><p><strong>创建数组</strong><br>Java语言使用new操作符来创建数组，语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arrayRefVar = <span class="keyword">new</span> dataType[arraySize];</span><br></pre></td></tr></table></figure><p>数组变量的声明，和创建数组可以用一条语句完成，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dataType[] arrayRefVar = <span class="keyword">new</span> dataType[arraySize];</span><br><span class="line">或</span><br><span class="line">dataType[] arrayRefVar = &#123;value0, value1, ..., valuek&#125;;</span><br></pre></td></tr></table></figure><p><strong>数组作为函数的返回值</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] reverse(<span class="keyword">int</span>[] list) &#123;</span><br><span class="line">  <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[list.length];</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = result.length - <span class="number">1</span>; i &lt; list.length; i++, j--) &#123;</span><br><span class="line">    result[j] = list[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h3><p>Java 集合框架主要包括两种类型的容器，一种是集合（Collection），存储一个元素集合，另一种是图（Map），存储键/值对映射。Collection 接口又有 3 种子类型，<strong>List</strong>、Set 和 Queue，再下面是一些抽象类，最后是具体实现类，常用的有 <strong>ArrayList</strong>、LinkedList、HashSet、LinkedHashSet、HashMap、LinkedHashMap 等。</p><p>集合框架是一个用来代表和操纵集合的统一架构。所有的集合框架都包含如下内容：</p><ul><li><strong>接口：</strong> 是代表集合的抽象数据类型。例如 Collection、List、Set、Map 等。之所以定义多个接口，是为了以不同的方式操作集合对象</li><li><strong>实现（类）：</strong> 是集合接口的具体实现。从本质上讲，它们是可重复使用的数据结构，例如：ArrayList、LinkedList、HashSet、HashMap。</li><li><strong>算法：</strong> 是实现集合接口的对象里的方法执行的一些有用的计算，例如：搜索和排序。这些算法被称为多态，那是因为相同的方法可以在相似的接口上有着不同的实现。</li></ul><p>除了集合，该框架也定义了几个 Map 接口和类。Map 里存储的是键/值对。尽管 Map 不是集合，但是它们完全整合在集合中。</p><h5 id="集合框架体系如下图所示"><a href="#集合框架体系如下图所示" class="headerlink" title="集合框架体系如下图所示"></a>集合框架体系如下图所示</h5><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200213185528810.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM2NTUzMA==,size_16,color_FFFFFF,t_70" class="lazyload"><br>Java 集合框架提供了一套性能优良，使用方便的接口和类，java集合框架位于java.util包中， 所以当使用集合框架的时候需要进行导包(Alt + Enter)<br>List和ArrayList主要区别是List是一个接口，而ArrayList是一个类，而且继承于List。这也意味着<strong>ArrayList是List的子类</strong>，在Java或者任何面向对象的语言找中，超类的变量都可以存储子类类型对象，这也称为多态</p><p>如下，定义了一个存储整形数据的集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.list;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 集合与数组主要区别是：集合相当于动态的数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListStudy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//等效于==&gt; List&lt;Integer&gt; list=new ArrayList&lt;&gt;();</span></span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        list.add(<span class="number">2</span>);</span><br><span class="line">        list.add(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"集合长度为："</span>+list.size());<span class="comment">//集合长度</span></span><br><span class="line">        System.out.println(<span class="string">"集合第一个元素为："</span>+list.get(<span class="number">0</span>));<span class="comment">//集合第一个元素</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 运行结果：</span></span><br><span class="line"><span class="comment"> * 1</span></span><br><span class="line"><span class="comment"> * 2</span></span><br><span class="line"><span class="comment"> * 3</span></span><br><span class="line"><span class="comment"> * 集合长度为：3</span></span><br><span class="line"><span class="comment"> * 集合第一个元素为：1</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h6 id="Java集合存储对象"><a href="#Java集合存储对象" class="headerlink" title="Java集合存储对象"></a>Java集合存储对象</h6><p>新建一个ListObject类并定义了name和age两个属性，生成对应的get、set方法和ListObject类的构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.list;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">//ListObject类的属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Alt + Insert --&gt;constructor，ListObject类的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListObject</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Alt + Insert--&gt;Getter and Setter</span></span><br><span class="line"><span class="comment">     * 生成get和set两个方法，对类的属性进行赋值(setName)和取值(getName)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>调用ListObject类</strong><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200213202835725.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM2NTUzMA==,size_16,color_FFFFFF,t_70" class="lazyload"></p><h6 id="应用：小程序获取集合数据"><a href="#应用：小程序获取集合数据" class="headerlink" title="应用：小程序获取集合数据"></a>应用：小程序获取集合数据</h6><p>Java后台程序，定义一个可供外部访问的getList方法(该方法返回一个List(列表))，在该方法中定义一个list集合<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200213210351343.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM2NTUzMA==,size_16,color_FFFFFF,t_70" class="lazyload"><br>如下，在小程序(前端)wxml中，添加一个block并用循环遍历后端返回的数据</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;block wx:for="&#123;&#123;ListData&#125;&#125;" wx:key="key"&gt;</span><br><span class="line">  &lt;view&gt;&#123;&#123;item&#125;&#125;&lt;/view&gt;</span><br><span class="line">&lt;/block&gt;</span><br></pre></td></tr></table></figure><p><strong>js文件中事件请求处理</strong><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200213211243632.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM2NTUzMA==,size_16,color_FFFFFF,t_70" class="lazyload"><br><strong>数据获取成功</strong><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200213211458542.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM2NTUzMA==,size_16,color_FFFFFF,t_70" class="lazyload"></p><h6 id="每天进步一点点，今天就分享到这里了。“人没有白学的东西，每一点都算数！”"><a href="#每天进步一点点，今天就分享到这里了。“人没有白学的东西，每一点都算数！”" class="headerlink" title="每天进步一点点，今天就分享到这里了。“人没有白学的东西，每一点都算数！”"></a>每天进步一点点，今天就分享到这里了。“人没有白学的东西，每一点都算数！”</h6>]]></content>
    
    <summary type="html">
    
      Java 集合框架主要包括两种类型的容器，一种是集合（Collection），存储一个元素集合，另一种是图（Map），存储键/值对映射。Collection 接口又有 3 种子类型，**List**、Set 和 Queue，再下面是一些抽象类，最后是具体实现类，常用的有 **ArrayList**、LinkedList、HashSet、LinkedHashSet、HashMap、LinkedHashMap 等。
    
    </summary>
    
    
      <category term="Java基础" scheme="http://vogos.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="http://vogos.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Windows中IIS和Serv-U两种方式搭建FTP服务</title>
    <link href="http://vogos.cn/2020/01/01/Windows%E4%B8%ADIIS%E5%92%8CServ-U%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E6%90%AD%E5%BB%BAFTP%E6%9C%8D%E5%8A%A1/"/>
    <id>http://vogos.cn/2020/01/01/Windows%E4%B8%ADIIS%E5%92%8CServ-U%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E6%90%AD%E5%BB%BAFTP%E6%9C%8D%E5%8A%A1/</id>
    <published>2020-01-01T04:31:43.000Z</published>
    <updated>2020-08-02T05:47:50.735Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200407133103120.gif#pic_center" class="lazyload"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;FTP是文件传输协议。用于互联网双向传输，控制文件下载空间在服务器复制文件从本地计算机或本地上传文件复制到服务器上的空间。</p><table><td bgcolor="#AEEEEE"></td></table><h1 id="iis搭建ftp站点"><a href="#iis搭建ftp站点" class="headerlink" title="iis搭建ftp站点"></a>iis搭建ftp站点</h1><p>&emsp;&emsp;Windows中使用IIS搭建ftp站点需要先开启IIS服务，步骤如下：</p><p><strong>打开控制面板，选择程序</strong><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200101105522514.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM2NTUzMA==,size_16,color_FFFFFF,t_70" class="lazyload"><br><strong>点击“启用或关闭Windows功能”</strong><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200101105647438.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM2NTUzMA==,size_16,color_FFFFFF,t_70" class="lazyload"><br><strong>按如下启用相关Windows功能：</strong><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200101110016546.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM2NTUzMA==,size_16,color_FFFFFF,t_70" class="lazyload"><br><strong>至此，IIS服务已启用，直接搜索iis并打开：</strong><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200101110335305.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM2NTUzMA==,size_16,color_FFFFFF,t_70" class="lazyload"><br><strong>展开左侧选项，右击“网站”，选择“添加FTP站点”</strong><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200101110901966.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM2NTUzMA==,size_16,color_FFFFFF,t_70" class="lazyload"><br><strong>填写站点名称，选择站点物理路径，下一步：</strong><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200101111623265.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM2NTUzMA==,size_16,color_FFFFFF,t_70" class="lazyload"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200101112325418.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM2NTUzMA==,size_16,color_FFFFFF,t_70" class="lazyload"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200101112654712.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM2NTUzMA==,size_16,color_FFFFFF,t_70" class="lazyload"><br><strong>搭建成功</strong><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200101112850736.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM2NTUzMA==,size_16,color_FFFFFF,t_70" class="lazyload"><br><strong>现在可通过浏览器或电脑地址栏输入 <a href="ftp://ip地址/" target="_blank" rel="noopener">ftp://ip地址</a> 访问到这个站点了，如下：</strong><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200101113457568.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM2NTUzMA==,size_16,color_FFFFFF,t_70" class="lazyload"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200101113812771.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM2NTUzMA==,size_16,color_FFFFFF,t_70" class="lazyload"><br>&emsp;&emsp;<strong>想让其他人也能访问到该站点的话，需要让你们的电脑在同一个局域网下，并且你的电脑(被访问的主机)需要关闭Windows的防火墙！</strong></p><table><td bgcolor="#AEEEEE"></td></table><h1 id="Serv-U搭建ftp站点"><a href="#Serv-U搭建ftp站点" class="headerlink" title="Serv-U搭建ftp站点"></a>Serv-U搭建ftp站点</h1><p>&emsp;&emsp;先科普一下Serv-U(百度来的)：Serv-U FTP Server，是一种被广泛运用的==FTP服务器端软件==，支持3x/9x/ME/NT/2K等全Windows系列。可以设定多个FTP服务器、限定登录用户的权限、登录主目录及空间大小等，功能非常完备。 它具有非常完备的安全特性，支持SSL FTP传输，支持在多个Serv-U和FTP客户端通过SSL加密连接保护您的数据安全等。</p><table><td bgcolor="#AEEEEE"></td></table><p>&emsp;&emsp;Serv-U直接去百度搜索下载就好了，就是容易下到捆绑软件，也可以在我的公众号  <strong>编程之外</strong> 回复 ==<strong>serv-u</strong>== 获取我下载好的软件包：</p><p><strong>下载解压后直接打开运行：</strong><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200101114812195.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM2NTUzMA==,size_16,color_FFFFFF,t_70" class="lazyload"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200101115613757.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM2NTUzMA==,size_16,color_FFFFFF,t_70" class="lazyload"><br><strong>与iis搭建方式相同，输入自己电脑的IP：</strong><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200101115746663.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM2NTUzMA==,size_16,color_FFFFFF,t_70" class="lazyload"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200101115849771.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM2NTUzMA==,size_16,color_FFFFFF,t_70" class="lazyload"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200101115935730.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM2NTUzMA==,size_16,color_FFFFFF,t_70" class="lazyload"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200101120125911.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM2NTUzMA==,size_16,color_FFFFFF,t_70" class="lazyload"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200101120240708.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM2NTUzMA==,size_16,color_FFFFFF,t_70" class="lazyload"><br><strong>用户名：</strong><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2020010112041340.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM2NTUzMA==,size_16,color_FFFFFF,t_70" class="lazyload"><br><strong>登录密码：</strong><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200101120503859.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM2NTUzMA==,size_16,color_FFFFFF,t_70" class="lazyload"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200101120619621.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM2NTUzMA==,size_16,color_FFFFFF,t_70" class="lazyload"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200101120651955.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM2NTUzMA==,size_16,color_FFFFFF,t_70" class="lazyload"><br><strong>FTP站点搭建完成：</strong><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200101120731367.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM2NTUzMA==,size_16,color_FFFFFF,t_70" class="lazyload"><br><strong>成功访问：</strong><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200101121032484.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM2NTUzMA==,size_16,color_FFFFFF,t_70" class="lazyload"><br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200101121116330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM2NTUzMA==,size_16,color_FFFFFF,t_70" class="lazyload"><br>&emsp;&emsp;至此，两种方式简单搭建FTP服务已完结，需要设置一些用户访问权限、并发用户数、文件上传/下载速度…啥啥啥的，博主这里就不详细赘述了(博主文采不是很好！)</p><table><td bgcolor="#AEEEEE"></td></table><h1 id="编程之外"><a href="#编程之外" class="headerlink" title="编程之外"></a>编程之外</h1><p>&emsp;&emsp;今天是2020年1月1日，新年快乐！本来想在昨晚，19年的最后一天就发这篇博文的…临时被安排去听一个<strong>校园网切割</strong>会议……..XXXXXXXXX（此处有几句大名鼎鼎的话语飘过！！）又是一个遗憾，19年遗憾太多，又一个轮回了希望今年自己会顺利些，不然我可能就要忍着滴血的痛，去买一小片猪肉拜神了。<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200408141514825.gif#pic_center" class="lazyload"></p><table><td bgcolor="green"><font size="3px" color="green">编程之外</font></td></table>]]></content>
    
    <summary type="html">
    
      FTP是文件传输协议。用于互联网双向传输，控制文件下载空间在服务器复制文件从本地计算机或本地上传文件复制到服务器上的空间。
    
    </summary>
    
    
      <category term="随笔" scheme="http://vogos.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="FTP" scheme="http://vogos.cn/tags/FTP/"/>
    
  </entry>
  
</feed>
